<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Paint</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        canvas {
            border: 1px solid #000;
            background-color: #fff;
            cursor: crosshair;
        }
        .controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        input[type="color"] {
            width: 50px;
            height: 40px;
            padding: 0;
            border: none;
            cursor: pointer;
        }
        input[type="range"] {
            width: 100px;
            cursor: pointer;
        }
        label {
            font-size: 16px;
        }
        select {
            padding: 5px;
            font-size: 16px;
            cursor: pointer;
        }
        input[type="file"] {
            display: none; /* Hide the file input */
        }
        .upload-label {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <canvas id="paintCanvas" width="800" height="600"></canvas>
    <div class="controls">
        <button id="saveButton">Save Image</button>
        <button id="clearButton">Clear Canvas</button>
        <button id="undoButton">Undo</button>
        <button id="redoButton">Redo</button>
        <input type="color" id="colorPicker" value="#000000">
        <label for="brushSize">Brush Size:</label>
        <input type="range" id="brushSize" min="1" max="50" value="5">
        <span id="brushSizeValue">5</span>
        <label for="brushType">Brush Type:</label>
        <select id="brushType">
            <option value="round">Round</option>
            <option value="square">Square</option>
            <option value="dotted">Dotted</option>
            <option value="paint">Paint Brush</option>
        </select>
        <label for="shapeType">Shape:</label>
        <select id="shapeType">
            <option value="none">None</option>
            <option value="circle">Circle</option>
            <option value="triangle">Triangle</option>
            <option value="rectangle">Rectangle</option>
            <option value="square">Square</option>
            <option value="polygon">Polygon</option>
        </select>
        <label for="backgroundColor">Background:</label>
        <input type="color" id="backgroundColor" value="#ffffff">
        <button id="setBackgroundButton">Set Background</button>
        <label for="uploadImage" class="upload-label">Upload Image</label>
        <input type="file" id="uploadImage" accept="image/*">
    </div>

    <script>
        const canvas = document.getElementById('paintCanvas');
        const ctx = canvas.getContext('2d');
        const saveButton = document.getElementById('saveButton');
        const clearButton = document.getElementById('clearButton');
        const undoButton = document.getElementById('undoButton');
        const redoButton = document.getElementById('redoButton');
        const colorPicker = document.getElementById('colorPicker');
        const brushSizeInput = document.getElementById('brushSize');
        const brushSizeValue = document.getElementById('brushSizeValue');
        const brushTypeSelect = document.getElementById('brushType');
        const shapeTypeSelect = document.getElementById('shapeType');
        const backgroundColorInput = document.getElementById('backgroundColor');
        const setBackgroundButton = document.getElementById('setBackgroundButton');
        const uploadImageInput = document.getElementById('uploadImage');

        let painting = false;
        let currentColor = '#000000'; // Default color
        let currentBrushSize = 5; // Default brush size
        let currentBrushType = 'round'; // Default brush type
        let currentShapeType = 'none'; // Default shape type
        let startX, startY; // Starting coordinates for shapes

        // Undo/redo functionality
        const maxHistorySteps = 10; // Maximum number of undo/redo steps
        let history = []; // Array to store canvas states
        let historyIndex = -1; // Current position in history

        // Save the current canvas state to history
        function saveState() {
            if (historyIndex < history.length - 1) {
                // If we're not at the latest state, remove future states
                history.splice(historyIndex + 1);
            }
            history.push(canvas.toDataURL()); // Save the canvas state
            if (history.length > maxHistorySteps) {
                // Remove the oldest state if history exceeds the limit
                history.shift();
            }
            historyIndex = history.length - 1; // Update the history index
            updateUndoRedoButtons();
        }

        // Undo the last action
        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                const img = new Image();
                img.src = history[historyIndex];
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                updateUndoRedoButtons();
            }
        }

        // Redo the last undone action
        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                const img = new Image();
                img.src = history[historyIndex];
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                updateUndoRedoButtons();
            }
        }

        // Update undo/redo button states
        function updateUndoRedoButtons() {
            undoButton.disabled = historyIndex <= 0;
            redoButton.disabled = historyIndex >= history.length - 1;
        }

        // Set the canvas background color
        function setBackgroundColor(color) {
            // Save the current drawing
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            // Fill the canvas with the new background color
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Redraw the saved content on top of the new background
            ctx.putImageData(imageData, 0, 0);

            // Save the updated state
            saveState();
        }

        // Upload image and draw it on the canvas
        uploadImageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        saveState(); // Save the state after uploading the image
                    };
                };
                reader.readAsDataURL(file);
            }
        });

        // Paste image from clipboard
        document.addEventListener('paste', (e) => {
            const items = e.clipboardData.items;
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    const blob = items[i].getAsFile();
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.src = event.target.result;
                        img.onload = () => {
                            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                            saveState(); // Save the state after pasting the image
                        };
                    };
                    reader.readAsDataURL(blob);
                }
            }
        });

        function startPosition(e) {
            painting = true;
            startX = e.clientX - canvas.offsetLeft;
            startY = e.clientY - canvas.offsetTop;

            if (currentShapeType === 'none') {
                draw(e);
            }
        }

        function endPosition(e) {
            if (!painting) return;

            const endX = e.clientX - canvas.offsetLeft;
            const endY = e.clientY - canvas.offsetTop;

            if (currentShapeType !== 'none') {
                drawShape(startX, startY, endX, endY);
            }

            painting = false;
            ctx.beginPath();

            // Save the canvas state after drawing
            saveState();
        }

        function draw(e) {
            if (!painting || currentShapeType !== 'none') return;

            ctx.lineWidth = currentBrushSize;
            ctx.strokeStyle = currentColor;

            // Set brush type
            switch (currentBrushType) {
                case 'round':
                    ctx.lineCap = 'round';
                    ctx.lineTo(e.clientX - canvas.offsetLeft, e.clientY - canvas.offsetTop);
                    ctx.stroke();
                    break;
                case 'square':
                    ctx.lineCap = 'square';
                    ctx.lineTo(e.clientX - canvas.offsetLeft, e.clientY - canvas.offsetTop);
                    ctx.stroke();
                    break;
                case 'dotted':
                    ctx.lineCap = 'round';
                    ctx.setLineDash([currentBrushSize / 2, currentBrushSize]); // Dotted effect
                    ctx.lineTo(e.clientX - canvas.offsetLeft, e.clientY - canvas.offsetTop);
                    ctx.stroke();
                    ctx.setLineDash([]); // Reset to solid line
                    break;
                case 'paint':
                    ctx.lineCap = 'round';
                    ctx.lineTo(e.clientX - canvas.offsetLeft, e.clientY - canvas.offsetTop);
                    ctx.stroke();
                    break;
            }

            ctx.beginPath();
            ctx.moveTo(e.clientX - canvas.offsetLeft, e.clientY - canvas.offsetTop);
        }

        function drawShape(startX, startY, endX, endY) {
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = currentBrushSize;

            switch (currentShapeType) {
                case 'circle':
                    const radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                    ctx.beginPath();
                    ctx.arc(startX, startY, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    break;
                case 'triangle':
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.lineTo(startX * 2 - endX, endY);
                    ctx.closePath();
                    ctx.stroke();
                    break;
                case 'rectangle':
                    ctx.strokeRect(startX, startY, endX - startX, endY - startY);
                    break;
                case 'square':
                    const size = Math.max(Math.abs(endX - startX), Math.abs(endY - startY));
                    ctx.strokeRect(startX, startY, size, size);
                    break;
                case 'polygon':
                    const sides = 6; // Hexagon
                    const angle = (Math.PI * 2) / sides;
                    const radiusPoly = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                    ctx.beginPath();
                    for (let i = 0; i < sides; i++) {
                        ctx.lineTo(
                            startX + Math.cos(angle * i) * radiusPoly,
                            startY + Math.sin(angle * i) * radiusPoly
                        );
                    }
                    ctx.closePath();
                    ctx.stroke();
                    break;
            }
        }

        canvas.addEventListener('mousedown', startPosition);
        canvas.addEventListener('mouseup', endPosition);
        canvas.addEventListener('mousemove', draw);

        saveButton.addEventListener('click', () => {
            const image = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = image;
            link.download = 'paint.png';
            link.click();
        });

        clearButton.addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            saveState(); // Save the cleared state
        });

        undoButton.addEventListener('click', undo);
        redoButton.addEventListener('click', redo);

        colorPicker.addEventListener('input', (e) => {
            currentColor = e.target.value; // Update the drawing color
        });

        brushSizeInput.addEventListener('input', (e) => {
            currentBrushSize = e.target.value; // Update the brush size
            brushSizeValue.textContent = currentBrushSize; // Update the displayed brush size
        });

        brushTypeSelect.addEventListener('change', (e) => {
            currentBrushType = e.target.value; // Update the brush type
        });

        shapeTypeSelect.addEventListener('change', (e) => {
            currentShapeType = e.target.value; // Update the shape type
        });

        setBackgroundButton.addEventListener('click', () => {
            const color = backgroundColorInput.value;
            setBackgroundColor(color); // Set the background color
        });

        // Initialize the canvas state
        setBackgroundColor('#ffffff'); // Set default background color
        saveState();
    </script>
</body>
</html>
