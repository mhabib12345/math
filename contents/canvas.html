<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Paint</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        canvas {
            border: 1px solid #000;
            background-color: #fff;
            cursor: crosshair;
        }
        .controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        input[type="color"] {
            width: 50px;
            height: 40px;
            padding: 0;
            border: none;
            cursor: pointer;
        }
        input[type="range"] {
            width: 100px;
            cursor: pointer;
        }
        label {
            font-size: 16px;
        }
        select {
            padding: 5px;
            font-size: 16px;
            cursor: pointer;
        }
        input[type="file"] {
            display: none; /* Hide the file input */
        }
        .upload-label {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <canvas id="paintCanvas" width="800" height="600"></canvas>
    <div class="controls">
        <button id="saveButton">Save Image</button>
        <button id="clearButton">Clear Canvas</button>
        <button id="undoButton">Undo</button>
        <button id="redoButton">Redo</button>
        <input type="color" id="colorPicker" value="#000000">
        <label for="brushSize">Brush Size:</label>
        <input type="range" id="brushSize" min="1" max="50" value="5">
        <span id="brushSizeValue">5</span>
        <label for="brushType">Brush Type:</label>
        <select id="brushType">
            <option value="round">Round</option>
            <option value="square">Square</option>
            <option value="dotted">Dotted</option>
            <option value="paint">Paint Brush</option>
        </select>
        <label for="shapeType">Shape:</label>
        <select id="shapeType">
            <option value="none">None</option>
            <option value="circle">Circle</option>
            <option value="triangle">Triangle</option>
            <option value="rectangle">Rectangle</option>
            <option value="square">Square</option>
            <option value="polygon">Polygon</option>
        </select>
        <label for="uploadImage" class="upload-label">Upload Image</label>
        <input type="file" id="uploadImage" accept="image/*">
    </div>

    <script>
        const canvas = document.getElementById('paintCanvas');
        const ctx = canvas.getContext('2d');
        const saveButton = document.getElementById('saveButton');
        const clearButton = document.getElementById('clearButton');
        const undoButton = document.getElementById('undoButton');
        const redoButton = document.getElementById('redoButton');
        const colorPicker = document.getElementById('colorPicker');
        const brushSizeInput = document.getElementById('brushSize');
        const brushSizeValue = document.getElementById('brushSizeValue');
        const brushTypeSelect = document.getElementById('brushType');
        const shapeTypeSelect = document.getElementById('shapeType');
        const uploadImageInput = document.getElementById('uploadImage');

        let painting = false;
        let currentColor = '#000000'; // Default color
        let currentBrushSize = 5; // Default brush size
        let currentBrushType = 'round'; // Default brush type
        let currentShapeType = 'none'; // Default shape type
        let startX, startY; // Starting coordinates for shapes

        // Track the uploaded/pasted image
        let image = null;
        let imageX = 0;
        let imageY = 0;
        let imageWidth = 0;
        let imageHeight = 0;
        let isDragging = false;
        let isResizing = false;
        let isImageEditingMode = false; // Whether we're in image editing mode
        let resizeHandleSize = 10;

        // Undo/redo functionality
        const maxHistorySteps = 10; // Maximum number of undo/redo steps
        let history = []; // Array to store canvas states
        let historyIndex = -1; // Current position in history

        // Save the current canvas state to history
        function saveState() {
            if (historyIndex < history.length - 1) {
                // If we're not at the latest state, remove future states
                history.splice(historyIndex + 1);
            }
            history.push(canvas.toDataURL()); // Save the canvas state
            if (history.length > maxHistorySteps) {
                // Remove the oldest state if history exceeds the limit
                history.shift();
            }
            historyIndex = history.length - 1; // Update the history index
            updateUndoRedoButtons();
        }

        // Undo the last action
        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                const img = new Image();
                img.src = history[historyIndex];
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                updateUndoRedoButtons();
            }
        }

        // Redo the last undone action
        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                const img = new Image();
                img.src = history[historyIndex];
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                updateUndoRedoButtons();
            }
        }

        // Update undo/redo button states
        function updateUndoRedoButtons() {
            undoButton.disabled = historyIndex <= 0;
            redoButton.disabled = historyIndex >= history.length - 1;
        }

        // Upload image and draw it on the canvas
        uploadImageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    image = new Image();
                    image.src = event.target.result;
                    image.onload = () => {
                        imageWidth = image.width;
                        imageHeight = image.height;
                        imageX = (canvas.width - imageWidth) / 2;
                        imageY = (canvas.height - imageHeight) / 2;
                        isImageEditingMode = true; // Enter image editing mode
                        drawCanvas();
                        saveState(); // Save the state after uploading the image
                    };
                };
                reader.readAsDataURL(file);
            }
        });

        // Paste image from clipboard
        document.addEventListener('paste', (e) => {
            const items = e.clipboardData.items;
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    const blob = items[i].getAsFile();
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        image = new Image();
                        image.src = event.target.result;
                        image.onload = () => {
                            imageWidth = image.width;
                            imageHeight = image.height;
                            imageX = (canvas.width - imageWidth) / 2;
                            imageY = (canvas.height - imageHeight) / 2;
                            isImageEditingMode = true; // Enter image editing mode
                            drawCanvas();
                            saveState(); // Save the state after pasting the image
                        };
                    };
                    reader.readAsDataURL(blob);
                }
            }
        });

        // Draw the canvas content
        function drawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (image) {
                ctx.drawImage(image, imageX, imageY, imageWidth, imageHeight);
                if (isImageEditingMode) {
                    drawResizeHandles();
                }
            }
        }

        // Draw resize handles
        function drawResizeHandles() {
            if (!image) return;
            ctx.fillStyle = 'blue';
            // Bottom-right corner handle
            ctx.fillRect(
                imageX + imageWidth - resizeHandleSize / 2,
                imageY + imageHeight - resizeHandleSize / 2,
                resizeHandleSize,
                resizeHandleSize
            );
        }

        // Check if the mouse is over the image
        function isMouseOverImage(x, y) {
            return (
                x >= imageX &&
                x <= imageX + imageWidth &&
                y >= imageY &&
                y <= imageY + imageHeight
            );
        }

        // Check if the mouse is over the resize handle
        function isMouseOverResizeHandle(x, y) {
            return (
                x >= imageX + imageWidth - resizeHandleSize &&
                x <= imageX + imageWidth &&
                y >= imageY + imageHeight - resizeHandleSize &&
                y <= imageY + imageHeight
            );
        }

        // Handle mouse down event
        function handleMouseDown(e) {
            const mouseX = e.clientX - canvas.offsetLeft;
            const mouseY = e.clientY - canvas.offsetTop;

            if (isImageEditingMode) {
                if (isMouseOverResizeHandle(mouseX, mouseY)) {
                    isResizing = true;
                } else if (isMouseOverImage(mouseX, mouseY)) {
                    isDragging = true;
                    startX = mouseX - imageX;
                    startY = mouseY - imageY;
                }
            } else {
                // Start brushing or drawing
                painting = true;
                startPosition(e);
            }
        }

        // Handle mouse move event
        function handleMouseMove(e) {
            const mouseX = e.clientX - canvas.offsetLeft;
            const mouseY = e.clientY - canvas.offsetTop;

            if (isImageEditingMode) {
                if (isDragging) {
                    imageX = mouseX - startX;
                    imageY = mouseY - startY;
                    drawCanvas();
                } else if (isResizing) {
                    imageWidth = mouseX - imageX;
                    imageHeight = mouseY - imageY;
                    drawCanvas();
                }
            } else if (painting) {
                draw(e);
            }
        }

        // Handle mouse up event
        function handleMouseUp() {
            if (isImageEditingMode) {
                isDragging = false;
                isResizing = false;
                saveState(); // Save the state after moving or resizing the image
            } else {
                painting = false;
                ctx.beginPath();
                saveState(); // Save the state after brushing
            }
        }

        // Handle double-click event to confirm image position and size
        function handleDoubleClick() {
            if (isImageEditingMode) {
                isImageEditingMode = false; // Exit image editing mode
                drawCanvas(); // Redraw without resize handles
                saveState(); // Save the final state
            }
        }

        function startPosition(e) {
            startX = e.clientX - canvas.offsetLeft;
            startY = e.clientY - canvas.offsetTop;
            draw(e);
        }

        function draw(e) {
            if (!painting) return;

            ctx.lineWidth = currentBrushSize;
            ctx.strokeStyle = currentColor;

            // Set brush type
            switch (currentBrushType) {
                case 'round':
                    ctx.lineCap = 'round';
                    ctx.lineTo(e.clientX - canvas.offsetLeft, e.clientY - canvas.offsetTop);
                    ctx.stroke();
                    break;
                case 'square':
                    ctx.lineCap = 'square';
                    ctx.lineTo(e.clientX - canvas.offsetLeft, e.clientY - canvas.offsetTop);
                    ctx.stroke();
                    break;
                case 'dotted':
                    ctx.lineCap = 'round';
                    ctx.setLineDash([currentBrushSize / 2, currentBrushSize]); // Dotted effect
                    ctx.lineTo(e.clientX - canvas.offsetLeft, e.clientY - canvas.offsetTop);
                    ctx.stroke();
                    ctx.setLineDash([]); // Reset to solid line
                    break;
                case 'paint':
                    ctx.lineCap = 'round';
                    ctx.lineTo(e.clientX - canvas.offsetLeft, e.clientY - canvas.offsetTop);
                    ctx.stroke();
                    break;
            }

            ctx.beginPath();
            ctx.moveTo(e.clientX - canvas.offsetLeft, e.clientY - canvas.offsetTop);
        }

        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('dblclick', handleDoubleClick);

        saveButton.addEventListener('click', () => {
            const image = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = image;
            link.download = 'paint.png';
            link.click();
        });

        clearButton.addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            image = null; // Clear the image
            isImageEditingMode = false; // Exit image editing mode
            saveState(); // Save the cleared state
        });

        undoButton.addEventListener('click', undo);
        redoButton.addEventListener('click', redo);

        colorPicker.addEventListener('input', (e) => {
            currentColor = e.target.value; // Update the drawing color
        });

        brushSizeInput.addEventListener('input', (e) => {
            currentBrushSize = e.target.value; // Update the brush size
            brushSizeValue.textContent = currentBrushSize; // Update the displayed brush size
        });

        brushTypeSelect.addEventListener('change', (e) => {
            currentBrushType = e.target.value; // Update the brush type
        });

        shapeTypeSelect.addEventListener('change', (e) => {
            currentShapeType = e.target.value; // Update the shape type
        });

        // Initialize the canvas state
        saveState();
    </script>
</body>
</html>
